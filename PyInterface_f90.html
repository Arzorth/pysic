

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pysic_interface (PyInterface.f90) &mdash; Pysic 0.5 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Pysic 0.5 documentation" href="index.html" />
    <link rel="up" title="Pysic Fortran module" href="pysic_fortran.html" />
    <link rel="next" title="pysic_core (Core.f90)" href="Core_f90.html" />
    <link rel="prev" title="Pysic Fortran module" href="pysic_fortran.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Core_f90.html" title="pysic_core (Core.f90)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pysic_fortran.html" title="Pysic Fortran module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pysic 0.5 documentation</a> &raquo;</li>
          <li><a href="pysic_fortran.html" accesskey="U">Pysic Fortran module</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pysic_interface (PyInterface.f90)</a><ul>
<li><a class="reference internal" href="#modules-used-by-pysic-interface">Modules used by pysic_interface</a></li>
<li><a class="reference internal" href="#list-of-subroutines-in-pysic-interface">List of subroutines in pysic_interface</a></li>
<li><a class="reference internal" href="#full-documentation-of-subroutines-in-pysic-interface">Full documentation of subroutines in pysic_interface</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pysic_fortran.html"
                        title="previous chapter">Pysic Fortran module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Core_f90.html"
                        title="next chapter">pysic_core (Core.f90)</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/PyInterface_f90.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pysic-interface-pyinterface-f90">
<span id="pysic-interface"></span><h1>pysic_interface (PyInterface.f90)<a class="headerlink" href="#pysic-interface-pyinterface-f90" title="Permalink to this headline">¶</a></h1>
<p>Pysic_interface is an interface module between the Python and Fortran
sides of pysic. When pysic is compiled, only this file is interfaced to
Python via <a class="reference external" href="http://www.scipy.org/F2py">f2py</a> while the rest of the Fortran source files are
directly compiled to .mod Fortran modules. The main reason for this
is that F90 derived types are used extensively in the core and these
are not yet (2011) supported by <a class="reference external" href="http://www.scipy.org/F2py">f2py</a> (although the support for
derived types is planned in third generation f2py). Because of this,
most data is passed from <a class="reference internal" href="pysic.html#module-pysic" title="pysic"><tt class="xref py py-mod docutils literal"><span class="pre">pysic</span></tt></a> to
<a class="reference internal" href="#pysic-interface"><em>pysic_interface (PyInterface.f90)</em></a> as NumPy arrays, and conversions from objects
is needed on both sides. This is cumbersome and adds overhead, but
it is not an efficiency issue since most of the information is only
passed from Python to Fortran once and saved. Even during a molecular
dynamics simulation only the forces, coordinates and momenta
of atoms need to be communicated through the interface, which is
naturally and efficiently handled using just numeric arrays anyway.</p>
<p>Another limitation in current <a class="reference external" href="http://www.scipy.org/F2py">f2py</a> is handling of string arrays.
To overcome this, string arrays are converted to integer arrays
and back using simple mapping functions in <tt class="xref py py-mod docutils literal"><span class="pre">pysic_utility</span></tt>
and <a class="reference internal" href="Utility_f90.html#utility"><em>utility (Utility.f90)</em></a>.</p>
<p>Due to the current limitations of <a class="reference external" href="http://www.scipy.org/F2py">f2py</a>, no derived types can appear
in the module. This severly limits what the module can do, and therefore
the module has been by design made to be very light in terms of
functionality: No data is stored in the module and almost all routines
simply redirect the call to a submodule, most often <a class="reference internal" href="Core_f90.html#pysic-core"><em>pysic_core (Core.f90)</em></a>.
In the descriptions of the routines in this documentation,
links are provided to the submodule routines that the call is directed
to, if the routine is just a redirect of the call.</p>
<div class="section" id="modules-used-by-pysic-interface">
<h2>Modules used by pysic_interface<a class="headerlink" href="#modules-used-by-pysic-interface" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="MPI_f90.html#mpi"><em>mpi (MPI.f90)</em></a></li>
<li><a class="reference internal" href="Mersenne_f90.html#mt95"><em>mt95 (Mersenne.f90)</em></a></li>
<li><a class="reference internal" href="Core_f90.html#pysic-core"><em>pysic_core (Core.f90)</em></a></li>
<li><a class="reference internal" href="Utility_f90.html#utility"><em>utility (Utility.f90)</em></a></li>
</ul>
</div>
<div class="section" id="list-of-subroutines-in-pysic-interface">
<h2>List of subroutines in pysic_interface<a class="headerlink" href="#list-of-subroutines-in-pysic-interface" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="#add_bond_order_factor" title="add_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">add_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#add_potential" title="add_potential"><tt class="xref py py-func docutils literal"><span class="pre">add_potential()</span></tt></a></li>
<li><a class="reference internal" href="#allocate_bond_order_factors" title="allocate_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">allocate_bond_order_factors()</span></tt></a></li>
<li><a class="reference internal" href="#allocate_bond_order_storage" title="allocate_bond_order_storage"><tt class="xref py py-func docutils literal"><span class="pre">allocate_bond_order_storage()</span></tt></a></li>
<li><a class="reference internal" href="#allocate_potentials" title="allocate_potentials"><tt class="xref py py-func docutils literal"><span class="pre">allocate_potentials()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_bond_order_factors" title="calculate_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">calculate_bond_order_factors()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_bond_order_gradients" title="calculate_bond_order_gradients"><tt class="xref py py-func docutils literal"><span class="pre">calculate_bond_order_gradients()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_bond_order_gradients_of_factor" title="calculate_bond_order_gradients_of_factor"><tt class="xref py py-func docutils literal"><span class="pre">calculate_bond_order_gradients_of_factor()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_electronegativities" title="calculate_electronegativities"><tt class="xref py py-func docutils literal"><span class="pre">calculate_electronegativities()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_energy" title="calculate_energy"><tt class="xref py py-func docutils literal"><span class="pre">calculate_energy()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_forces" title="calculate_forces"><tt class="xref py py-func docutils literal"><span class="pre">calculate_forces()</span></tt></a></li>
<li><a class="reference internal" href="#clear_potential_multipliers" title="clear_potential_multipliers"><tt class="xref py py-func docutils literal"><span class="pre">clear_potential_multipliers()</span></tt></a></li>
<li><a class="reference internal" href="#create_atoms" title="create_atoms"><tt class="xref py py-func docutils literal"><span class="pre">create_atoms()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor_list" title="create_bond_order_factor_list"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor_list()</span></tt></a></li>
<li><a class="reference internal" href="#create_cell" title="create_cell"><tt class="xref py py-func docutils literal"><span class="pre">create_cell()</span></tt></a></li>
<li><a class="reference internal" href="#create_neighbor_list" title="create_neighbor_list"><tt class="xref py py-func docutils literal"><span class="pre">create_neighbor_list()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_list" title="create_potential_list"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_list()</span></tt></a></li>
<li><a class="reference internal" href="#description_of_bond_order_factor" title="description_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">description_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#description_of_potential" title="description_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">description_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#descriptions_of_parameters_of_bond_order_factor" title="descriptions_of_parameters_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">descriptions_of_parameters_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#descriptions_of_parameters_of_potential" title="descriptions_of_parameters_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">descriptions_of_parameters_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#distribute_mpi" title="distribute_mpi"><tt class="xref py py-func docutils literal"><span class="pre">distribute_mpi()</span></tt></a></li>
<li><a class="reference internal" href="#examine_atoms" title="examine_atoms"><tt class="xref py py-func docutils literal"><span class="pre">examine_atoms()</span></tt></a></li>
<li><a class="reference internal" href="#examine_bond_order_factors" title="examine_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">examine_bond_order_factors()</span></tt></a></li>
<li><a class="reference internal" href="#examine_cell" title="examine_cell"><tt class="xref py py-func docutils literal"><span class="pre">examine_cell()</span></tt></a></li>
<li><a class="reference internal" href="#examine_potentials" title="examine_potentials"><tt class="xref py py-func docutils literal"><span class="pre">examine_potentials()</span></tt></a></li>
<li><a class="reference internal" href="#finish_mpi" title="finish_mpi"><tt class="xref py py-func docutils literal"><span class="pre">finish_mpi()</span></tt></a></li>
<li><a class="reference internal" href="#generate_neighbor_lists" title="generate_neighbor_lists"><tt class="xref py py-func docutils literal"><span class="pre">generate_neighbor_lists()</span></tt></a></li>
<li><a class="reference internal" href="#get_cell_vectors" title="get_cell_vectors"><tt class="xref py py-func docutils literal"><span class="pre">get_cell_vectors()</span></tt></a></li>
<li><a class="reference internal" href="#get_cpu_id" title="get_cpu_id"><tt class="xref py py-func docutils literal"><span class="pre">get_cpu_id()</span></tt></a></li>
<li><a class="reference internal" href="#get_ewald_energy" title="get_ewald_energy"><tt class="xref py py-func docutils literal"><span class="pre">get_ewald_energy()</span></tt></a></li>
<li><a class="reference internal" href="#get_mpi_list_of_atoms" title="get_mpi_list_of_atoms"><tt class="xref py py-func docutils literal"><span class="pre">get_mpi_list_of_atoms()</span></tt></a></li>
<li><a class="reference internal" href="#get_neighbor_list_of_atom" title="get_neighbor_list_of_atom"><tt class="xref py py-func docutils literal"><span class="pre">get_neighbor_list_of_atom()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_atoms" title="get_number_of_atoms"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_atoms()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_cpus" title="get_number_of_cpus"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_cpus()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_neighbors_of_atom" title="get_number_of_neighbors_of_atom"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_neighbors_of_atom()</span></tt></a></li>
<li><a class="reference internal" href="#is_bond_order_factor" title="is_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">is_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#is_potential" title="is_potential"><tt class="xref py py-func docutils literal"><span class="pre">is_potential()</span></tt></a></li>
<li><a class="reference internal" href="#level_of_bond_order_factor" title="level_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">level_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#list_valid_bond_order_factors" title="list_valid_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">list_valid_bond_order_factors()</span></tt></a></li>
<li><a class="reference internal" href="#list_valid_potentials" title="list_valid_potentials"><tt class="xref py py-func docutils literal"><span class="pre">list_valid_potentials()</span></tt></a></li>
<li><a class="reference internal" href="#names_of_parameters_of_bond_order_factor" title="names_of_parameters_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">names_of_parameters_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#names_of_parameters_of_potential" title="names_of_parameters_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">names_of_parameters_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#number_of_bond_order_factors" title="number_of_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">number_of_bond_order_factors()</span></tt></a></li>
<li><a class="reference internal" href="#number_of_parameters_of_bond_order_factor" title="number_of_parameters_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">number_of_parameters_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#number_of_parameters_of_potential" title="number_of_parameters_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">number_of_parameters_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#number_of_potentials" title="number_of_potentials"><tt class="xref py py-func docutils literal"><span class="pre">number_of_potentials()</span></tt></a></li>
<li><a class="reference internal" href="#number_of_targets_of_bond_order_factor" title="number_of_targets_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">number_of_targets_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#number_of_targets_of_potential" title="number_of_targets_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">number_of_targets_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#release" title="release"><tt class="xref py py-func docutils literal"><span class="pre">release()</span></tt></a></li>
<li><a class="reference internal" href="#set_ewald_parameters" title="set_ewald_parameters"><tt class="xref py py-func docutils literal"><span class="pre">set_ewald_parameters()</span></tt></a></li>
<li><a class="reference internal" href="#start_bond_order_factors" title="start_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">start_bond_order_factors()</span></tt></a></li>
<li><a class="reference internal" href="#start_mpi" title="start_mpi"><tt class="xref py py-func docutils literal"><span class="pre">start_mpi()</span></tt></a></li>
<li><a class="reference internal" href="#start_potentials" title="start_potentials"><tt class="xref py py-func docutils literal"><span class="pre">start_potentials()</span></tt></a></li>
<li><a class="reference internal" href="#start_rng" title="start_rng"><tt class="xref py py-func docutils literal"><span class="pre">start_rng()</span></tt></a></li>
<li><a class="reference internal" href="#sync_mpi" title="sync_mpi"><tt class="xref py py-func docutils literal"><span class="pre">sync_mpi()</span></tt></a></li>
<li><a class="reference internal" href="#update_atom_charges" title="update_atom_charges"><tt class="xref py py-func docutils literal"><span class="pre">update_atom_charges()</span></tt></a></li>
<li><a class="reference internal" href="#update_atom_coordinates" title="update_atom_coordinates"><tt class="xref py py-func docutils literal"><span class="pre">update_atom_coordinates()</span></tt></a></li>
</ul>
</div>
<div class="section" id="full-documentation-of-subroutines-in-pysic-interface">
<h2>Full documentation of subroutines in pysic_interface<a class="headerlink" href="#full-documentation-of-subroutines-in-pysic-interface" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="function">
<dt id="add_bond_order_factor">
<tt class="descname">add_bond_order_factor</tt><big>(</big><em>n_targets</em>, <em>n_params</em>, <em>n_split</em>, <em>bond_name</em>, <em>parameters</em>, <em>param_split</em>, <em>cutoff</em>, <em>smooth_cut</em>, <em>elements</em>, <em>orig_elements</em>, <em>group_index</em>, <em>success</em><big>)</big><a class="headerlink" href="#add_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a bond order factor in the core.
The memory must have been allocated first using allocate_potentials.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_add_bond_order_factor" title="core_add_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">core_add_bond_order_factor()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets (interacting bodies)</dd>
<dt>n_params: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of parameters</dd>
<dt>n_split: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of subsets in the list of parameters, should equal n_targets</dd>
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>bond order factor names</dd>
<dt>parameters: double precision  <em>intent(in)</em>    <em>size(n_params)</em></dt>
<dd>numeric parameters</dd>
<dt>param_split: integer  <em>intent(in)</em>    <em>size(n_split)</em></dt>
<dd>the numbers of parameters for 1-body, 2-body etc.</dd>
<dt>cutoff: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>interaction hard cutoff</dd>
<dt>smooth_cut: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>interaction soft cutoff</dd>
<dt>elements: integer  <em>intent(in)</em>    <em>size(2, n_targets)</em></dt>
<dd>atomic symbols specifying the elements the interaction acts on</dd>
<dt>orig_elements: integer  <em>intent(in)</em>    <em>size(2, n_targets)</em></dt>
<dd>original atomic symbols specifying the elements the interaction acts on</dd>
<dt>group_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index denoting the potential to which the factor is connected</dd>
<dt><strong>success</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>logical tag specifying if creation of the factor succeeded</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="add_potential">
<tt class="descname">add_potential</tt><big>(</big><em>n_targets</em>, <em>n_params</em>, <em>pot_name</em>, <em>parameters</em>, <em>cutoff</em>, <em>smooth_cut</em>, <em>elements</em>, <em>tags</em>, <em>indices</em>, <em>orig_elements</em>, <em>orig_tags</em>, <em>orig_indices</em>, <em>pot_index</em>, <em>is_multiplier</em>, <em>success</em><big>)</big><a class="headerlink" href="#add_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a potential in the core.
The memory must have been allocated first using allocate_potentials.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_add_potential" title="core_add_potential"><tt class="xref py py-func docutils literal"><span class="pre">core_add_potential()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets (interacting bodies)</dd>
<dt>n_params: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of parameters</dd>
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>potential names</dd>
<dt>parameters: double precision  <em>intent(in)</em>    <em>size(n_params)</em></dt>
<dd>numeric parameters</dd>
<dt>cutoff: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>interaction hard cutoff</dd>
<dt>smooth_cut: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>interaction soft cutoff</dd>
<dt>elements: integer  <em>intent(in)</em>    <em>size(2, n_targets)</em></dt>
<dd>atomic symbols specifying the elements the interaction acts on</dd>
<dt>tags: integer  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>tags specifying the atoms the interaction acts on</dd>
<dt>indices: integer  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>indices specifying the atoms the interaction acts on</dd>
<dt>orig_elements: integer  <em>intent(in)</em>    <em>size(2, n_targets)</em></dt>
<dd>original atomic symbols specifying the elements the interaction acts on</dd>
<dt>orig_tags: integer  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>original tags specifying the atoms the interaction acts on</dd>
<dt>orig_indices: integer  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>original indices specifying the atoms the interaction acts on</dd>
<dt>pot_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
<dt>is_multiplier: logical  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>logical tag defining if the potential is a multiplier for a product potential</dd>
<dt><strong>success</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>logical tag specifying if creation of the potential succeeded</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="allocate_bond_order_factors">
<tt class="descname">allocate_bond_order_factors</tt><big>(</big><em>n_bonds</em><big>)</big><a class="headerlink" href="#allocate_bond_order_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates memory for storing bond order parameters for describing the atomic interactions.
Similar to the allocate_potentials routine.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_allocate_bond_order_factors" title="core_allocate_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">core_allocate_bond_order_factors()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_bonds: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of bond order factors</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="allocate_bond_order_storage">
<tt class="descname">allocate_bond_order_storage</tt><big>(</big><em>n_atoms</em>, <em>n_groups</em>, <em>n_factors</em><big>)</big><a class="headerlink" href="#allocate_bond_order_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates memory for storing bond order factors for describing the atomic interactions.
The difference to allocate_bond_order_factors is that this method allocates
space for arrays used in storing actual calculated bond order factors. The other
routine allocates space for storing the parameters used in the calculations.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_allocate_bond_order_storage" title="core_allocate_bond_order_storage"><tt class="xref py py-func docutils literal"><span class="pre">core_allocate_bond_order_storage()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt>n_groups: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of bond order groups</dd>
<dt>n_factors: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of bond order parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="allocate_potentials">
<tt class="descname">allocate_potentials</tt><big>(</big><em>n_pots</em><big>)</big><a class="headerlink" href="#allocate_potentials" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates memory for storing potentials for describing the atomic interactions.
It is more convenient to loop through the potentials and format them in a
suitable way in python than in fortran. Therefore the core is first called
through this routine in order to allocate memory for the potentials.
Then, each potential is created individually.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_allocate_potentials" title="core_allocate_potentials"><tt class="xref py py-func docutils literal"><span class="pre">core_allocate_potentials()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_pots: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of potentials</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_bond_order_factors">
<tt class="descname">calculate_bond_order_factors</tt><big>(</big><em>n_atoms</em>, <em>group_index</em>, <em>bond_orders</em><big>)</big><a class="headerlink" href="#calculate_bond_order_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns bond order factors of the given group for all atoms.
The group index is an identifier for the bond order parameters
which are used for calculating one and the same factors.
In practice, the Coordinators in pysic are indexed and this
indexing is copied in the core. Thus the group index specifies
the coordinator / potential.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_get_bond_order_factors" title="core_get_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">core_get_bond_order_factors()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt>group_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index for the bond order factor group</dd>
<dt><strong>bond_orders</strong>: double precision  <strong>intent(out)</strong>    <em>size(n_atoms)</em></dt>
<dd>the calculated bond order factors</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_bond_order_gradients">
<tt class="descname">calculate_bond_order_gradients</tt><big>(</big><em>n_atoms</em>, <em>group_index</em>, <em>atom_index</em>, <em>gradients</em><big>)</big><a class="headerlink" href="#calculate_bond_order_gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns bond order factors gradients of the given group.
The gradients of all factors are given with respect to moving the given atom.
The group index is an identifier for the bond order parameters
which are used for calculating one and the same factors.
In practice, the Coordinators in pysic are indexed and this
indexing is copied in the core. Thus the group index specifies
the coordinator / potential.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_get_bond_order_sums" title="core_get_bond_order_sums"><tt class="xref py py-func docutils literal"><span class="pre">core_get_bond_order_sums()</span></tt></a></p>
<p>and <a class="reference internal" href="Core_f90.html#core_calculate_bond_order_gradients" title="core_calculate_bond_order_gradients"><tt class="xref py py-func docutils literal"><span class="pre">core_calculate_bond_order_gradients()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt>group_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>an index denoting the potential to which the factor is connected</dd>
<dt>atom_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the atom with respect to which the factors are differentiated</dd>
<dt><strong>gradients</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, n_atoms)</em></dt>
<dd>the calculated bond order gradients</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_bond_order_gradients_of_factor">
<tt class="descname">calculate_bond_order_gradients_of_factor</tt><big>(</big><em>n_atoms</em>, <em>group_index</em>, <em>atom_index</em>, <em>gradients</em><big>)</big><a class="headerlink" href="#calculate_bond_order_gradients_of_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns bond order factors gradients of the given group.
The gradients of the given factors is given with respect to moving all atoms.
The group index is an identifier for the bond order parameters
which are used for calculating one and the same factors.
In practice, the Coordinators in pysic are indexed and this
indexing is copied in the core. Thus the group index specifies
the coordinator / potential.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_get_bond_order_sums" title="core_get_bond_order_sums"><tt class="xref py py-func docutils literal"><span class="pre">core_get_bond_order_sums()</span></tt></a></p>
<p>and <a class="reference internal" href="Core_f90.html#core_calculate_bond_order_gradients_of_factor" title="core_calculate_bond_order_gradients_of_factor"><tt class="xref py py-func docutils literal"><span class="pre">core_calculate_bond_order_gradients_of_factor()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt>group_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>an index denoting the potential to which the factor is connected</dd>
<dt>atom_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the atom whose factor is differentiated</dd>
<dt><strong>gradients</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, n_atoms)</em></dt>
<dd>the calculated bond order gradients</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_electronegativities">
<tt class="descname">calculate_electronegativities</tt><big>(</big><em>n_atoms</em>, <em>enegs</em><big>)</big><a class="headerlink" href="#calculate_electronegativities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns electronegativities of the particles</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_calculate_electronegativities" title="core_calculate_electronegativities"><tt class="xref py py-func docutils literal"><span class="pre">core_calculate_electronegativities()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt><strong>enegs</strong>: double precision  <strong>intent(out)</strong>    <em>size(n_atoms)</em></dt>
<dd>array of electronegativities on all atoms</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_energy">
<tt class="descname">calculate_energy</tt><big>(</big><em>energy</em><big>)</big><a class="headerlink" href="#calculate_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total potential energy of the system</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_calculate_energy" title="core_calculate_energy"><tt class="xref py py-func docutils literal"><span class="pre">core_calculate_energy()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>total potential energy</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_forces">
<tt class="descname">calculate_forces</tt><big>(</big><em>n_atoms</em>, <em>forces</em>, <em>stress</em><big>)</big><a class="headerlink" href="#calculate_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns forces acting on the particles and the stress tensor</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_calculate_forces" title="core_calculate_forces"><tt class="xref py py-func docutils literal"><span class="pre">core_calculate_forces()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt><strong>forces</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, n_atoms)</em></dt>
<dd>array of forces on all atoms</dd>
<dt><strong>stress</strong>: double precision  <strong>intent(out)</strong>    <em>size(6)</em></dt>
<dd>array containing the components of the stress tensor (in order <span class="math">\(xx,yy,zz,yz,xz,xy\)</span>)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="clear_potential_multipliers">
<tt class="descname">clear_potential_multipliers</tt><big>(</big><big>)</big><a class="headerlink" href="#clear_potential_multipliers" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the temporary stored array of multiplier potentials</p>
</dd></dl>

<dl class="function">
<dt id="create_atoms">
<tt class="descname">create_atoms</tt><big>(</big><em>n_atoms</em>, <em>masses</em>, <em>charges</em>, <em>positions</em>, <em>momenta</em>, <em>tags</em>, <em>elements</em><big>)</big><a class="headerlink" href="#create_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates atomic particles.
Atoms are handled as custom fortran types <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> in the core. Currently
<a class="reference external" href="http://www.scipy.org/F2py">f2py</a> does not support direct creation of types from Python, so instead
all the necessary data is passed from Python as arrays and reassembled
as types in Fortran. This is not much of an added overhead - the
memory allocation itself already makes this a routine one does not
wish to call repeatedly. Instead, one should call the routines
for updating atoms whenever the actual atoms do not change
(e.g., between MD timesteps).</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_generate_atoms" title="core_generate_atoms"><tt class="xref py py-func docutils literal"><span class="pre">core_generate_atoms()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt>masses: double precision  <em>intent(in)</em>    <em>size(n_atoms)</em></dt>
<dd>masses of atoms</dd>
<dt>charges: double precision  <em>intent(in)</em>    <em>size(n_atoms)</em></dt>
<dd>electric charges of atoms</dd>
<dt>positions: double precision  <em>intent(in)</em>    <em>size(3, n_atoms)</em></dt>
<dd>coordinates of atoms</dd>
<dt>momenta: double precision  <em>intent(in)</em>    <em>size(3, n_atoms)</em></dt>
<dd>momenta of atoms</dd>
<dt>tags: integer  <em>intent(in)</em>    <em>size(n_atoms)</em></dt>
<dd>numeric tags for the atoms</dd>
<dt>elements: integer  <em>intent(in)</em>    <em>size(2, n_atoms)</em></dt>
<dd>atomic symbols of the atoms</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor_list">
<tt class="descname">create_bond_order_factor_list</tt><big>(</big><big>)</big><a class="headerlink" href="#create_bond_order_factor_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Similarly to the potential lists, also list containing all the
bond order factors that may affect an atom are stored in a list.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_assign_bond_order_factor_indices" title="core_assign_bond_order_factor_indices"><tt class="xref py py-func docutils literal"><span class="pre">core_assign_bond_order_factor_indices()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="create_cell">
<tt class="descname">create_cell</tt><big>(</big><em>vectors</em>, <em>inverse</em>, <em>periodicity</em><big>)</big><a class="headerlink" href="#create_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a supercell for containing the calculation geometry
Also the inverse cell matrix must be given,
although it is not checked that the given inverse actually
is the true inverse.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_create_cell" title="core_create_cell"><tt class="xref py py-func docutils literal"><span class="pre">core_create_cell()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>vectors: double precision  <em>intent(in)</em>    <em>size(3, 3)</em></dt>
<dd>A 3x3 matrix containing the vectors spanning the supercell. The first index runs over xyz and the second index runs over the three vectors.</dd>
<dt>inverse: double precision  <em>intent(in)</em>    <em>size(3, 3)</em></dt>
<dd>A 3x3 matrix containing the inverse matrix of the one given in vectors, i.e. <span class="math">\(M^{-1}*M = I\)</span> for the two matrices. Since the latter represents a cell of non-zero volume, this inverse must exist. It is not tested that the given matrix actually is the inverse, the user must make sure it is.</dd>
<dt>periodicity: logical  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>A 3-element vector containing logical tags specifying if the system is periodic in the directions of the three vectors spanning the supercell.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_neighbor_list">
<tt class="descname">create_neighbor_list</tt><big>(</big><em>n_nbs</em>, <em>atom_index</em>, <em>neighbors</em>, <em>offsets</em><big>)</big><a class="headerlink" href="#create_neighbor_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates neighbor lists for a single atom
telling it which other atoms are in its
immediate neighborhood.
The neighbor list must be precalculated, this method only
stores them in the core. The list must contain
an array storing the indices of the neighboring atoms
as well as the supercell offsets. The offsets are integer
triplets showing how many times must the supercell vectors
be added to the position of the neighbor to find the
neighboring image in a periodic system.
Note that if the system is small, one atom can in
principle appear several times in the neighbor list.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_create_neighbor_list" title="core_create_neighbor_list"><tt class="xref py py-func docutils literal"><span class="pre">core_create_neighbor_list()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_nbs: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of neighbors</dd>
<dt>atom_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the atom for which the neighbor list is created</dd>
<dt>neighbors: integer  <em>intent(in)</em>    <em>size(n_nbs)</em></dt>
<dd>An array containing the indices of the neighboring atoms</dd>
<dt>offsets: integer  <em>intent(in)</em>    <em>size(3, n_nbs)</em></dt>
<dd>An array containing vectors specifying the offsets of the neighbors in periodic systems.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_list">
<tt class="descname">create_potential_list</tt><big>(</big><big>)</big><a class="headerlink" href="#create_potential_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a list of indices for all atoms showing which potentials
act on them.
The user may define many potentials to sum up the potential energy of the
system. However, if some potentials only act on certain atoms, they will
be redundant for the other atoms. The potential lists are lists
given to each atom containing the potentials which can act on the
atom.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_assign_potential_indices" title="core_assign_potential_indices"><tt class="xref py py-func docutils literal"><span class="pre">core_assign_potential_indices()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="description_of_bond_order_factor">
<tt class="descname">description_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>description</em><big>)</big><a class="headerlink" href="#description_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a description of the given bond order factor</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_description_of_bond_order_factor" title="get_description_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_description_of_bond_order_factor()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt><strong>description</strong>: character(len=500)  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>description of the bond order actor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="description_of_potential">
<tt class="descname">description_of_potential</tt><big>(</big><em>pot_name</em>, <em>description</em><big>)</big><a class="headerlink" href="#description_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a description of the given potential</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_description_of_potential" title="get_description_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_description_of_potential()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt><strong>description</strong>: character(len=500)  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>description of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="descriptions_of_parameters_of_bond_order_factor">
<tt class="descname">descriptions_of_parameters_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>n_targets</em>, <em>param_notes</em><big>)</big><a class="headerlink" href="#descriptions_of_parameters_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists descriptions for parameters the given bond order factor.
Output is an array of integers. This is because <a class="reference external" href="http://www.scipy.org/F2py">f2py</a> doesn&#8217;t
currently support string arrays. So, the characters are translated to
integers and back in fortran and python.
This adds a bit of overhead, but the routine is only invoked
on user command so it doesn&#8217;t matter.</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_descriptions_of_parameters_of_bond_order_factor" title="get_descriptions_of_parameters_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_descriptions_of_parameters_of_bond_order_factor()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt><strong>param_notes</strong>: integer  <strong>intent(out)</strong>    <em>size(100, 12)</em></dt>
<dd>descriptions of the parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="descriptions_of_parameters_of_potential">
<tt class="descname">descriptions_of_parameters_of_potential</tt><big>(</big><em>pot_name</em>, <em>param_notes</em><big>)</big><a class="headerlink" href="#descriptions_of_parameters_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists descriptions for parameters the given potential.
Output is an array of integers. This is because <a class="reference external" href="http://www.scipy.org/F2py">f2py</a> doesn&#8217;t
currently support string arrays. So, the characters are translated to
integers and back in fortran and python.
This adds a bit of overhead, but the routine is only invoked
on user command so it doesn&#8217;t matter.</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_descriptions_of_parameters_of_potential" title="get_descriptions_of_parameters_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_descriptions_of_parameters_of_potential()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt><strong>param_notes</strong>: integer  <strong>intent(out)</strong>    <em>size(100, 12)</em></dt>
<dd>descriptions of the parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="distribute_mpi">
<tt class="descname">distribute_mpi</tt><big>(</big><em>n_atoms</em><big>)</big><a class="headerlink" href="#distribute_mpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Distributes atoms among the processors.
In the MPI scheme, atoms are distributed among
the cpus for force and energy calculations.
This routine initializes the arrays that
tell each cpu which atoms it has to calculate
interactions for. It can be called before
the atoms are created in the core but one has to
make sure the number of atoms specified in the last call
matches the number of atoms in the core when a
calculation is invoked.</p>
<p>Calls <a class="reference internal" href="MPI_f90.html#mpi_distribute" title="mpi_distribute"><tt class="xref py py-func docutils literal"><span class="pre">mpi_distribute()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="examine_atoms">
<tt class="descname">examine_atoms</tt><big>(</big><big>)</big><a class="headerlink" href="#examine_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints some information about the atoms allocated in the core.
This is mainly for debugging, as the python side should always
dictate what is in the core.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#list_atoms" title="list_atoms"><tt class="xref py py-func docutils literal"><span class="pre">list_atoms()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="examine_bond_order_factors">
<tt class="descname">examine_bond_order_factors</tt><big>(</big><big>)</big><a class="headerlink" href="#examine_bond_order_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints some information about the bond order factors allocated in the core.
This is mainly for debugging, as the python side should always
dictate what is in the core.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#list_bonds" title="list_bonds"><tt class="xref py py-func docutils literal"><span class="pre">list_bonds()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="examine_cell">
<tt class="descname">examine_cell</tt><big>(</big><big>)</big><a class="headerlink" href="#examine_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints some information about the supercell allocated in the core.
This is mainly for debugging, as the python side should always
dictate what is in the core.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#list_cell" title="list_cell"><tt class="xref py py-func docutils literal"><span class="pre">list_cell()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="examine_potentials">
<tt class="descname">examine_potentials</tt><big>(</big><big>)</big><a class="headerlink" href="#examine_potentials" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints some information about the potential allocated in the core.
This is mainly for debugging, as the python side should always
dictate what is in the core.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#list_interactions" title="list_interactions"><tt class="xref py py-func docutils literal"><span class="pre">list_interactions()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="finish_mpi">
<tt class="descname">finish_mpi</tt><big>(</big><big>)</big><a class="headerlink" href="#finish_mpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Finishes MPI for parallel calculations.</p>
<p>Calls <a class="reference internal" href="MPI_f90.html#mpi_finish" title="mpi_finish"><tt class="xref py py-func docutils literal"><span class="pre">mpi_finish()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="generate_neighbor_lists">
<tt class="descname">generate_neighbor_lists</tt><big>(</big><em>n_atoms</em>, <em>cutoffs</em><big>)</big><a class="headerlink" href="#generate_neighbor_lists" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates and allocates neighbor lists</p>
<p>Parameters:</p>
<p>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></p>
<p>cutoffs: double precision  <em>intent(in)</em>    <em>size(n_atoms)</em></p>
</dd></dl>

<dl class="function">
<dt id="get_cell_vectors">
<tt class="descname">get_cell_vectors</tt><big>(</big><em>vectors</em><big>)</big><a class="headerlink" href="#get_cell_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vectors defining the simulation supercell.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_get_cell_vectors" title="core_get_cell_vectors"><tt class="xref py py-func docutils literal"><span class="pre">core_get_cell_vectors()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt><strong>vectors</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 3)</em></dt>
<dd>A 3x3 matrix containing the vectors spanning the supercell. The first index runs over xyz and the second index runs over the three vectors.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_cpu_id">
<tt class="descname">get_cpu_id</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#get_cpu_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the MPI cpu id number, which is an
integer between 0 and <span class="math">\(n_\mathrm{cpus}-1\)</span>,
where <span class="math">\(n_\mathrm{cpus}\)</span> is the total
number of cpus.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt><strong>id</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>cpu id number in MPI - 0 in serial mode</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_ewald_energy">
<tt class="descname">get_ewald_energy</tt><big>(</big><em>real_cut</em>, <em>k_cut</em>, <em>reciprocal_cut</em>, <em>sigma</em>, <em>epsilon</em>, <em>energy</em><big>)</big><a class="headerlink" href="#get_ewald_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Debugging routine for Ewald</p>
<p>Parameters:</p>
<p>real_cut: double precision  <em>intent(in)</em>    <em>scalar</em></p>
<p>k_cut: double precision  <em>intent(in)</em>    <em>scalar</em></p>
<p>reciprocal_cut: integer  <em>intent(in)</em>    <em>size(3)</em></p>
<p>sigma: double precision  <em>intent(in)</em>    <em>scalar</em></p>
<p>epsilon: double precision  <em>intent(in)</em>    <em>scalar</em></p>
<p><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></p>
</dd></dl>

<dl class="function">
<dt id="get_mpi_list_of_atoms">
<tt class="descname">get_mpi_list_of_atoms</tt><big>(</big><em>n_atoms</em>, <em>cpu_atoms</em><big>)</big><a class="headerlink" href="#get_mpi_list_of_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a logical array containing true for every
atom that is allocated to this cpu, and false
for all other atoms.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt><strong>cpu_atoms</strong>: logical  <strong>intent(out)</strong>    <em>size(n_atoms)</em></dt>
<dd>array of logical values showing which atoms are marked to be handled by this cpu</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_neighbor_list_of_atom">
<tt class="descname">get_neighbor_list_of_atom</tt><big>(</big><em>atom_index</em>, <em>n_neighbors</em>, <em>neighbors</em>, <em>offsets</em><big>)</big><a class="headerlink" href="#get_neighbor_list_of_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of neighbors for an atom</p>
<p>Parameters:</p>
<p>atom_index: integer  <em>intent(in)</em>    <em>scalar</em></p>
<p>n_neighbors: integer  <em>intent(in)</em>    <em>scalar</em></p>
<p><strong>neighbors</strong>: integer  <strong>intent(out)</strong>    <em>size(n_neighbors)</em></p>
<p><strong>offsets</strong>: integer  <strong>intent(out)</strong>    <em>size(3, n_neighbors)</em></p>
</dd></dl>

<dl class="function">
<dt id="get_number_of_atoms">
<tt class="descname">get_number_of_atoms</tt><big>(</big><em>n_atoms</em><big>)</big><a class="headerlink" href="#get_number_of_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of atoms in the current core</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_get_number_of_atoms" title="core_get_number_of_atoms"><tt class="xref py py-func docutils literal"><span class="pre">core_get_number_of_atoms()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt><strong>n_atoms</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of atoms</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_cpus">
<tt class="descname">get_number_of_cpus</tt><big>(</big><em>ncpu</em><big>)</big><a class="headerlink" href="#get_number_of_cpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the MPI cpu count</p>
<p>Parameters:</p>
<dl class="docutils">
<dt><strong>ncpu</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the total number of cpus available</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_neighbors_of_atom">
<tt class="descname">get_number_of_neighbors_of_atom</tt><big>(</big><em>atom_index</em>, <em>n_neighbors</em><big>)</big><a class="headerlink" href="#get_number_of_neighbors_of_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of neighbors for an atom</p>
<p>Parameters:</p>
<p>atom_index: integer  <em>intent(in)</em>    <em>scalar</em></p>
<p><strong>n_neighbors</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></p>
</dd></dl>

<dl class="function">
<dt id="is_bond_order_factor">
<tt class="descname">is_bond_order_factor</tt><big>(</big><em>string</em>, <em>is_ok</em><big>)</big><a class="headerlink" href="#is_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells whether a given keyword defines a bond order factor or not</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#is_valid_bond_order_factor" title="is_valid_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">is_valid_bond_order_factor()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>string: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of a bond order factor</dd>
<dt><strong>is_ok</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>true if string is a name of a bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="is_potential">
<tt class="descname">is_potential</tt><big>(</big><em>string</em>, <em>is_ok</em><big>)</big><a class="headerlink" href="#is_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells whether a given keyword defines a potential or not</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#is_valid_potential" title="is_valid_potential"><tt class="xref py py-func docutils literal"><span class="pre">is_valid_potential()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>string: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of a potential</dd>
<dt><strong>is_ok</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>true if string is a name of a potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="level_of_bond_order_factor">
<tt class="descname">level_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>n_target</em><big>)</big><a class="headerlink" href="#level_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells the level of a bond order factor has, i.e., is it per-atom or per-pair</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_level_of_bond_order_factor" title="get_level_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_level_of_bond_order_factor()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt><strong>n_target</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of targets</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="list_valid_bond_order_factors">
<tt class="descname">list_valid_bond_order_factors</tt><big>(</big><em>n_bonds</em>, <em>bond_factors</em><big>)</big><a class="headerlink" href="#list_valid_bond_order_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all the keywords which define a bond order factor</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#list_bond_order_factors" title="list_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">list_bond_order_factors()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_bonds: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of bond order factor types</dd>
<dt><strong>bond_factors</strong>: integer  <strong>intent(out)</strong>    <em>size(11, n_bonds)</em></dt>
<dd>names of the bond order factor types</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="list_valid_potentials">
<tt class="descname">list_valid_potentials</tt><big>(</big><em>n_pots</em>, <em>potentials</em><big>)</big><a class="headerlink" href="#list_valid_potentials" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all the keywords which define a potential</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#list_potentials" title="list_potentials"><tt class="xref py py-func docutils literal"><span class="pre">list_potentials()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_pots: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of potential types</dd>
<dt><strong>potentials</strong>: integer  <strong>intent(out)</strong>    <em>size(11, n_pots)</em></dt>
<dd>names of the potential types</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="names_of_parameters_of_bond_order_factor">
<tt class="descname">names_of_parameters_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>n_targets</em>, <em>param_names</em><big>)</big><a class="headerlink" href="#names_of_parameters_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists the names of parameters the given bond order factor knows.
Output is an array of integers. This is because <a class="reference external" href="http://www.scipy.org/F2py">f2py</a> doesn&#8217;t
currently support string arrays. So, the characters are translated to
integers and back in fortran and python.
This adds a bit of overhead, but the routine is only invoked
on user command so it doesn&#8217;t matter.</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_names_of_parameters_of_bond_order_factor" title="get_names_of_parameters_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_names_of_parameters_of_bond_order_factor()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt><strong>param_names</strong>: integer  <strong>intent(out)</strong>    <em>size(10, 12)</em></dt>
<dd>names of the parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="names_of_parameters_of_potential">
<tt class="descname">names_of_parameters_of_potential</tt><big>(</big><em>pot_name</em>, <em>param_names</em><big>)</big><a class="headerlink" href="#names_of_parameters_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists the names of parameters the given potential knows.
Output is an array of integers. This is because <a class="reference external" href="http://www.scipy.org/F2py">f2py</a> doesn&#8217;t
currently support string arrays. So, the characters are translated to
integers and back in fortran and python.
This adds a bit of overhead, but the routine is only invoked
on user command so it doesn&#8217;t matter.</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_names_of_parameters_of_potential" title="get_names_of_parameters_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_names_of_parameters_of_potential()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt><strong>param_names</strong>: integer  <strong>intent(out)</strong>    <em>size(10, 12)</em></dt>
<dd>names of the parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="number_of_bond_order_factors">
<tt class="descname">number_of_bond_order_factors</tt><big>(</big><em>n_bonds</em><big>)</big><a class="headerlink" href="#number_of_bond_order_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells the number of differently named bond order factors the core knows</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_number_of_bond_order_factors" title="get_number_of_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_bond_order_factors()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt><strong>n_bonds</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of bond order factors</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="number_of_parameters_of_bond_order_factor">
<tt class="descname">number_of_parameters_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>n_targets</em>, <em>n_params</em><big>)</big><a class="headerlink" href="#number_of_parameters_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells how many numeric parameters a bond order factor incorporates</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_number_of_parameters_of_bond_order_factor" title="get_number_of_parameters_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_parameters_of_bond_order_factor()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt><strong>n_params</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="number_of_parameters_of_potential">
<tt class="descname">number_of_parameters_of_potential</tt><big>(</big><em>pot_name</em>, <em>n_params</em><big>)</big><a class="headerlink" href="#number_of_parameters_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells how many numeric parameters a potential incorporates</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_number_of_parameters_of_potential" title="get_number_of_parameters_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_parameters_of_potential()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt><strong>n_params</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="number_of_potentials">
<tt class="descname">number_of_potentials</tt><big>(</big><em>n_pots</em><big>)</big><a class="headerlink" href="#number_of_potentials" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells the number of differently named potentials the core knows</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_number_of_potentials" title="get_number_of_potentials"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_potentials()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt><strong>n_pots</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of potentials</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="number_of_targets_of_bond_order_factor">
<tt class="descname">number_of_targets_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>n_target</em><big>)</big><a class="headerlink" href="#number_of_targets_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells how many targets a bond order factor has, i.e., is it many-body</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_number_of_targets_of_bond_order_factor" title="get_number_of_targets_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_targets_of_bond_order_factor()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt><strong>n_target</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of targets</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="number_of_targets_of_potential">
<tt class="descname">number_of_targets_of_potential</tt><big>(</big><em>pot_name</em>, <em>n_target</em><big>)</big><a class="headerlink" href="#number_of_targets_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells how many targets a potential has, i.e., is it a many-body potential</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#get_number_of_targets_of_potential" title="get_number_of_targets_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_targets_of_potential()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt><strong>n_target</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of targets</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#release" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocates all the arrays in the core</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_release_all_memory" title="core_release_all_memory"><tt class="xref py py-func docutils literal"><span class="pre">core_release_all_memory()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="set_ewald_parameters">
<tt class="descname">set_ewald_parameters</tt><big>(</big><em>n_atoms</em>, <em>real_cut</em>, <em>k_radius</em>, <em>reciprocal_cut</em>, <em>sigma</em>, <em>epsilon</em>, <em>scaler</em><big>)</big><a class="headerlink" href="#set_ewald_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the parameters for Ewald summation in the core.</p>
<p>Parameters:</p>
<p>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></p>
<dl class="docutils">
<dt>real_cut: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the real-space cutoff</dd>
<dt>k_radius: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the k-space cutoff</dd>
<dt>reciprocal_cut: integer  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>the k-space cutoffs (in numbers of cells)</dd>
<dt>sigma: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the split parameter</dd>
<dt>epsilon: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>electric constant</dd>
<dt>scaler: double precision  <em>intent(in)</em>    <em>size(n_atoms)</em></dt>
<dd>scaling factors for the individual charges</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="start_bond_order_factors">
<tt class="descname">start_bond_order_factors</tt><big>(</big><big>)</big><a class="headerlink" href="#start_bond_order_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the bond order factors.
A routine is called to generate descriptors for
potentials. These descriptors are needed by the
python interface in order to directly inquire
the core on the types of factors available.</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#initialize_bond_order_factor_characterizers" title="initialize_bond_order_factor_characterizers"><tt class="xref py py-func docutils literal"><span class="pre">initialize_bond_order_factor_characterizers()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="start_mpi">
<tt class="descname">start_mpi</tt><big>(</big><big>)</big><a class="headerlink" href="#start_mpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes MPI for parallel calculations.</p>
<p>Calls <a class="reference internal" href="MPI_f90.html#mpi_initialize" title="mpi_initialize"><tt class="xref py py-func docutils literal"><span class="pre">mpi_initialize()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="start_potentials">
<tt class="descname">start_potentials</tt><big>(</big><big>)</big><a class="headerlink" href="#start_potentials" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the potentials.
A routine is called to generate descriptors for
potentials. These descriptors are needed by the
python interface in order to directly inquire
the core on the types of potentials available.</p>
<p>Calls <a class="reference internal" href="Potentials_f90.html#initialize_potential_characterizers" title="initialize_potential_characterizers"><tt class="xref py py-func docutils literal"><span class="pre">initialize_potential_characterizers()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="start_rng">
<tt class="descname">start_rng</tt><big>(</big><em>seed</em><big>)</big><a class="headerlink" href="#start_rng" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize Mersenne Twister random number generator.</p>
<p>A seed number has to be given. In case we run in MPI
mode, the master cpu will broadcast its seed to all other
cpus to ensure that the random number sequences match
in all the cpus.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>seed: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a seed for the random number generator</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="sync_mpi">
<tt class="descname">sync_mpi</tt><big>(</big><big>)</big><a class="headerlink" href="#sync_mpi" title="Permalink to this definition">¶</a></dt>
<dd><p>Syncs MPI.
This just calls mpi_barrier, so it makes all cpus
wait until everyone is at this particular point in
execution.</p>
<p>Calls <a class="reference internal" href="MPI_f90.html#mpi_sync" title="mpi_sync"><tt class="xref py py-func docutils literal"><span class="pre">mpi_sync()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="update_atom_charges">
<tt class="descname">update_atom_charges</tt><big>(</big><em>n_atoms</em>, <em>charges</em><big>)</big><a class="headerlink" href="#update_atom_charges" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the charges of existing atoms.
This method does not allocate memory and so the atoms
must already exist in the core.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_update_atom_charges" title="core_update_atom_charges"><tt class="xref py py-func docutils literal"><span class="pre">core_update_atom_charges()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt>charges: double precision  <em>intent(in)</em>    <em>size(n_atoms)</em></dt>
<dd>new charges for the atoms</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="update_atom_coordinates">
<tt class="descname">update_atom_coordinates</tt><big>(</big><em>n_atoms</em>, <em>positions</em>, <em>momenta</em><big>)</big><a class="headerlink" href="#update_atom_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the positions and velocities of existing atoms.
This method does not allocate memory and so the atoms
must already exist in the core.</p>
<p>Calls <a class="reference internal" href="Core_f90.html#core_update_atom_coordinates" title="core_update_atom_coordinates"><tt class="xref py py-func docutils literal"><span class="pre">core_update_atom_coordinates()</span></tt></a></p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of atoms</dd>
<dt>positions: double precision  <em>intent(in)</em>    <em>size(3, n_atoms)</em></dt>
<dd>new coordinates for the atoms</dd>
<dt>momenta: double precision  <em>intent(in)</em>    <em>size(3, n_atoms)</em></dt>
<dd>new momenta for the atoms</dd>
</dl>
</dd></dl>

</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Core_f90.html" title="pysic_core (Core.f90)"
             >next</a> |</li>
        <li class="right" >
          <a href="pysic_fortran.html" title="Pysic Fortran module"
             >previous</a> |</li>
        <li><a href="index.html">Pysic 0.5 documentation</a> &raquo;</li>
          <li><a href="pysic_fortran.html" >Pysic Fortran module</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2013, Teemu Hynninen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>